<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title> - RFCs book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="An online book of fellowship RFCs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Approved</li><li class="chapter-item expanded "><a href="../approved/0001-agile-coretime.html"><strong aria-hidden="true">1.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0005-coretime-interface.html"><strong aria-hidden="true">2.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0007-system-collator-selection.html"><strong aria-hidden="true">3.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0008-parachain-bootnodes-dht.html"><strong aria-hidden="true">4.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0012-process-for-adding-new-collectives.html"><strong aria-hidden="true">5.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0014-improve-locking-mechanism-for-parachains.html"><strong aria-hidden="true">6.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0022-adopt-encointer-runtime.html"><strong aria-hidden="true">7.</strong> </a></li><li class="chapter-item expanded "><a href="../approved/0032-minimal-relay.html"><strong aria-hidden="true">8.</strong> </a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Proposed</li><li class="chapter-item expanded "><a href="../proposed/0004-remove-unnecessary-allocator-usage.html"><strong aria-hidden="true">9.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0006-dynamic-pricing-for-bulk-coretime-sales.html"><strong aria-hidden="true">10.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0009-improved-net-light-client-requests.html"><strong aria-hidden="true">11.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/000x-assethub.html"><strong aria-hidden="true">12.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0010-burn-coretime-revenue.html"><strong aria-hidden="true">13.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0011-add-new-path-to-account-creation-on-asset-hubs.html"><strong aria-hidden="true">14.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0013-prepare-blockbuilder-and-core-runtime-apis-for-mbms.html"><strong aria-hidden="true">15.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0015-market-design-revisit.html"><strong aria-hidden="true">16.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0020-treasurer-track-confirmation-period-duration-modification.html"><strong aria-hidden="true">17.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0026-sassafras-consensus.html"><strong aria-hidden="true">18.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0031-corejam.html"><strong aria-hidden="true">19.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0034-xcm-absolute-location-account-derivation.html"><strong aria-hidden="true">20.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0035-conviction-voting-delegation-modifications.html"><strong aria-hidden="true">21.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0042-extrinsics-state-version.html"><strong aria-hidden="true">22.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0043-storage-proof-size-hostfunction.html"><strong aria-hidden="true">23.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0044-rent-based-registration.html"><strong aria-hidden="true">24.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0046-metadata-for-offline-signers.html"><strong aria-hidden="true">25.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0047-random-assignment-of-availability-chunks.html" class="active"><strong aria-hidden="true">26.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0048-session-keys-runtime-api.html"><strong aria-hidden="true">27.</strong> </a></li><li class="chapter-item expanded "><a href="../proposed/0050-fellowship-salaries.html"><strong aria-hidden="true">28.</strong> </a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RFCs book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://api.github.com/repos/polkadot-fellows/RFCs/pulls/47">(source)</a></p>
<h1 id="rfc-0047-random-assignment-of-availability-chunks-to-validators"><a class="header" href="#rfc-0047-random-assignment-of-availability-chunks-to-validators">RFC-0047: Random assignment of availability chunks to validators</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Start Date</strong></td><td>03 November 2023</td></tr>
<tr><td><strong>Description</strong></td><td>An evenly-distributing indirection layer between availability chunks and validators.</td></tr>
<tr><td><strong>Authors</strong></td><td>Alin Dima</td></tr>
</tbody></table>
</div>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Propose a way of randomly permuting the availability chunk indices assigned to validators for a given core and relay
chain block, in the context of
<a href="https://github.com/paritytech/polkadot-sdk/issues/598">recovering available data from systematic chunks</a>, with the
purpose of fairly distributing network bandwidth usage.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Currently, the ValidatorIndex is always identical to the ChunkIndex. Since the validator array is only shuffled once
per session, naively using the ValidatorIndex as the ChunkIndex would pose an unreasonable stress on the first N/3
validators during an entire session, when favouring availability recovery from systematic chunks.</p>
<p>Therefore, the relay chain node needs a deterministic way of evenly distributing the first ~(N_VALIDATORS / 3)
systematic availability chunks to different validators, based on the session, relay chain block and core.
The main purpose is to ensure fair distribution of network bandwidth usage for availability recovery in general and in
particular for systematic chunk holders. </p>
<h2 id="stakeholders"><a class="header" href="#stakeholders">Stakeholders</a></h2>
<p>Relay chain node core developers.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<h3 id="systematic-erasure-codes"><a class="header" href="#systematic-erasure-codes">Systematic erasure codes</a></h3>
<p>An erasure coding algorithm is considered systematic if it preserves the original unencoded data as part of the
resulting code.
<a href="https://github.com/paritytech/reed-solomon-novelpoly">The implementation of the erasure coding algorithm used for polkadot's availability data</a> is systematic.
Roughly speaking, the first N_VALIDATORS/3 chunks of data can be cheaply concatenated to retrieve the original data,
without running the resource-intensive and time-consuming reconstruction algorithm.</p>
<p>Here's the concatenation procedure of systematic chunks for polkadot's erasure coding algorithm
(minus error handling, for briefness):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn reconstruct_from_systematic&lt;T: Decode&gt;(
	n_validators: usize,
	chunks: Vec&lt;&amp;[u8]&gt;,
) -&gt; T {
	let mut threshold = (n_validators - 1) / 3;
	if !is_power_of_two(threshold) {
		threshold = next_lower_power_of_2(threshold);
	}

	let shard_len = chunks.iter().next().unwrap().len();

	let mut systematic_bytes = Vec::with_capacity(shard_len * threshold);

	for i in (0..shard_len).step_by(2) {
		for chunk in chunks.iter().take(threshold) {
			systematic_bytes.push(chunk[i]);
			systematic_bytes.push(chunk[i + 1]);
		}
	}

	Decode::decode(&amp;mut &amp;systematic_bytes[..]).map_err(|err| Error::Decode(err))
}
<span class="boring">}</span></code></pre></pre>
<p>In a nutshell, it performs a column-wise concatenation with 2-byte chunks.</p>
<h3 id="availability-recovery-now"><a class="header" href="#availability-recovery-now">Availability recovery now</a></h3>
<p>According to the <a href="https://spec.polkadot.network/chapter-anv#sect-candidate-recovery">polkadot protocol spec</a>:</p>
<blockquote>
<p>A validator should request chunks by picking peers randomly and must recover at least <code>f+1</code> chunks, where
<code>n=3f+k</code> and <code>k in {1,2,3}</code>.</p>
</blockquote>
<p>For parity's polkadot node implementation, the process was further optimised. At this moment, it works differently based
on the estimated size of the available data:</p>
<p>(a) for small PoVs (up to 128 Kib), sequentially try requesting the unencoded data from the backing group, in a random
order. If this fails, fallback to option (b).</p>
<p>(b) for large PoVs (over 128 Kib), launch N parallel requests for the erasure coded chunks (currently, N has an upper
limit of 50), until enough chunks were recovered. Validators are tried in a random order. Then, reconstruct the
original data.</p>
<h3 id="availability-recovery-from-systematic-chunks"><a class="header" href="#availability-recovery-from-systematic-chunks">Availability recovery from systematic chunks</a></h3>
<p>As part of the effort of
<a href="https://github.com/paritytech/roadmap/issues/26">increasing polkadot's resource efficiency, scalability and performance</a>,
work is under way to modify the Availability Recovery protocol by leveraging systematic chunks. See
<a href="https://github.com/paritytech/polkadot-sdk/issues/598#issuecomment-1792007099">this comment</a> for preliminary
performance results.</p>
<p>In this scheme, the relay chain node will first attempt to retrieve the ~N/3 systematic chunks from the validators that
should hold them, before falling back to recovering from regular chunks, as before.</p>
<h3 id="chunk-assignment-function"><a class="header" href="#chunk-assignment-function">Chunk assignment function</a></h3>
<h4 id="properties"><a class="header" href="#properties">Properties</a></h4>
<p>The function that decides the chunk index for a validator should be parameterized by at least
<code>(validator_index, relay_parent, para_id)</code>
and have the following properties:</p>
<ol>
<li>deterministic</li>
<li>pseudo-random</li>
<li>relatively quick to compute and resource-efficient.</li>
<li>when considering the other params besides <code>validator_index</code> as fixed, the function should describe a random permutation
of the chunk indices</li>
<li>considering <code>relay_parent</code> as a fixed argument, the validators that map to the first N/3 chunk indices should
have as little overlap as possible for different paras scheduled on that relay parent.</li>
</ol>
<p>In other words, we want a uniformly distributed, deterministic mapping from <code>ValidatorIndex</code> to <code>ChunkIndex</code> per block
per scheduled para.</p>
<h4 id="proposed-runtime-api"><a class="header" href="#proposed-runtime-api">Proposed runtime API</a></h4>
<p>The mapping function should be implemented as a runtime API, because:</p>
<ol>
<li>it enables further atomic changes to the shuffling algorithm.</li>
<li>it enables alternative client implementations (in other languages) to use it</li>
<li>considering how critical it is for parachain consensus that all validators have a common view of the Validator-&gt;Chunk
mapping, this mitigates the problem of third-party libraries changing the implementations of the <code>ChaCha8Rng</code> or the <code>rand::shuffle</code>
that could be introduced in further versions. This would stall parachains if only a portion of validators upgraded the node.</li>
</ol>
<p>Pseudocode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_chunk_index(
  n_validators: u32,
  validator_index: ValidatorIndex,
  relay_parent: Hash,
  para_id: ParaId
) -&gt; ChunkIndex {
  let threshold = systematic_threshold(n_validators); // Roughly n_validators/3
  let seed = derive_seed(relay_parent);
  let mut rng: ChaCha8Rng = SeedableRng::from_seed(seed);
  let mut chunk_indices: Vec&lt;ChunkIndex&gt; = (0..n_validators).map(Into::into).collect();
  chunk_indices.shuffle(&amp;mut rng);

  let seed = derive_seed(hash(para_id));
  let mut rng: ChaCha8Rng = SeedableRng::from_seed(seed);
  let para_start_pos = rng.gen_range(0..n_validators);

  chunk_indices[(para_start_pos + validator_index) % n_validators]
}
<span class="boring">}</span></code></pre></pre>
<p>Additionally, so that client code is able to efficiently get the mapping from the runtime, another API will be added
for retrieving chunk indices in bulk for all validators at a given block and core:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_chunk_indices(
  n_validators: u32,
  relay_parent: Hash,
  para_id: ParaId
) -&gt; Vec&lt;ChunkIndex&gt; {
  let threshold = systematic_threshold(n_validators); // Roughly n_validators/3
  let seed = derive_seed(relay_parent);
  let mut rng: ChaCha8Rng = SeedableRng::from_seed(seed);
  let mut chunk_indices: Vec&lt;ChunkIndex&gt; = (0..n_validators).map(Into::into).collect();
  chunk_indices.shuffle(&amp;mut rng);

  let seed = derive_seed(hash(para_id));
  let mut rng: ChaCha8Rng = SeedableRng::from_seed(seed);

  let para_start_pos = rng.gen_range(0..n_validators);

  chunk_indices
    .into_iter()
    .cycle()
    .skip(para_start_pos)
    .take(n_validators)
    .collect()
}
<span class="boring">}</span></code></pre></pre>
<h4 id="upgrade-path"><a class="header" href="#upgrade-path">Upgrade path</a></h4>
<p>Considering that the Validator-&gt;Chunk mapping is critical to para consensus, the change needs to be enacted atomically
via governance, only after all validators have upgraded the node to a version that is aware of this mapping.
It needs to be explicitly stated that after the runtime upgrade and governance enactment, validators that run older
client versions that don't support this mapping will not be able to participate in parachain consensus.</p>
<p>Additionally, an error will be logged when starting a validator with an older version, after the runtime was upgraded and the feature enabled.</p>
<h2 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h2>
<ul>
<li>In terms of guaranteeing even load distribution, a simpler function that chooses the per-core start position in the
shuffle as <code>threshold * core_index</code> would likely perform better, but considering that the core_index is not part of the
CandidateReceipt, the implementation would be too complicated. More details in <a href="#appendix-a">Appendix A</a>.</li>
<li>Considering future protocol changes that aim to generalise the work polkadot is doing (like CoreJam), <code>ParaId</code>s may be
removed from the protocol, in favour of more generic primitives. In that case, <code>ParaId</code>s in the availability recovery
process should be replaced with a similar identifier. It's important to note that the implementation is greatly simplified
if this identifier is part of the <code>CandidateReceipt</code> or the future analogous data structure.</li>
<li>It's a breaking change that requires most validators to be upgrade their node version.</li>
</ul>
<h2 id="testing-security-and-privacy"><a class="header" href="#testing-security-and-privacy">Testing, Security, and Privacy</a></h2>
<p>Extensive testing will be conducted - both automated and manual.
This proposal doesn't affect security or privacy.</p>
<h2 id="performance-ergonomics-and-compatibility"><a class="header" href="#performance-ergonomics-and-compatibility">Performance, Ergonomics, and Compatibility</a></h2>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>This is a necessary data availability optimisation, as reed-solomon erasure coding has proven to be a top consumer of
CPU time in polkadot as we scale up the parachain block size and number of availability cores.</p>
<p>With this optimisation, preliminary performance results show that CPU time used for reed-solomon coding can be halved
and total POV recovery time decrease by 80% for large POVs. See more
<a href="https://github.com/paritytech/polkadot-sdk/issues/598#issuecomment-1792007099">here</a>.</p>
<h3 id="ergonomics"><a class="header" href="#ergonomics">Ergonomics</a></h3>
<p>Not applicable.</p>
<h3 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h3>
<p>This is a breaking change. See <a href="#upgrade-path">upgrade path</a> section above.
All validators need to have upgraded their node versions before the feature will be enabled via a runtime upgrade and
governance call.</p>
<h2 id="prior-art-and-references"><a class="header" href="#prior-art-and-references">Prior Art and References</a></h2>
<p>See comments on the <a href="https://github.com/paritytech/polkadot-sdk/issues/598">tracking issue</a> and the
<a href="https://github.com/paritytech/polkadot-sdk/pull/1644">in-progress PR</a></p>
<h2 id="unresolved-questions"><a class="header" href="#unresolved-questions">Unresolved Questions</a></h2>
<ul>
<li>Is it the best option to embed the mapping function in the runtime?</li>
<li>Is there a better upgrade path that would preserve backwards compatibility?</li>
<li>Is usage of <code>ParaId</code> the best choice for spreading out the network load during systematic chunk recovery within the
same block?</li>
</ul>
<h2 id="future-directions-and-related-material"><a class="header" href="#future-directions-and-related-material">Future Directions and Related Material</a></h2>
<p>This enables future optimisations for the performance of availability recovery, such as retrieving batched systematic
chunks from backers/approval-checkers.</p>
<h2 id="appendix-a"><a class="header" href="#appendix-a">Appendix A</a></h2>
<p>This appendix explores alternatives to using the <code>ParaId</code> as the factor by which availability chunk indices are
distributed to validators within the same relay chain block, and why they weren't chosen.</p>
<h3 id="core-index"><a class="header" href="#core-index">Core index</a></h3>
<p>Here, <code>core_index</code> refers to the index of the core that a candidate was occupying while it was pending availability
(from backing to inclusion).</p>
<p>Availability-recovery can currently be triggered by the following phases in the polkadot protocol:</p>
<ol>
<li>During the approval voting process.</li>
<li>By other collators of the same parachain.</li>
<li>During disputes.</li>
</ol>
<p>Getting the right core index for a candidate is troublesome. Here's a breakdown of how different parts of the
node implementation can get access to it:</p>
<ol>
<li>
<p>The approval-voting process for a candidate begins after observing that the candidate was included. Therefore, the
node has easy access to the block where the candidate got included (and also the core that it occupied).</p>
</li>
<li>
<p>The <code>pov_recovery</code> task of the collators starts availability recovery in response to noticing a candidate getting
backed, which enables easy access to the core index the candidate started occupying.</p>
</li>
<li>
<p>Disputes may be initiated on a number of occasions:</p>
<p>3.a. is initiated by the validator as a result of finding an invalid candidate while participating in the
approval-voting protocol. In this case, availability-recovery is not needed, since the validator already issued their
vote.</p>
<p>3.b is initiated by the validator noticing dispute votes recorded on-chain. In this case, we can safely
assume that the backing event for that candidate has been recorded and kept in memory.</p>
<p>3.c is initiated as a result of getting a dispute statement from another validator. It is possible that the dispute
is happening on a fork that was not yet imported by this validator, so the subsystem may not have seen this candidate
being backed.</p>
</li>
</ol>
<p>A naive attempt of solving 3.c would be to add a new version for the disputes request-response networking protocol.
Blindly passing the core index in the network payload would not work, since there is no way of validating that
the reported core_index was indeed the one occupied by the candidate at the respective relay parent.</p>
<p>Another attempt could be to include in the message the relay block hash where the candidate was included.
This information would be used in order to query the runtime API and retrieve the core index that the candidate was
occupying. However, considering it's part of an unimported fork, the validator cannot call a runtime API on that block.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../proposed/0046-metadata-for-offline-signers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../proposed/0048-session-keys-runtime-api.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../proposed/0046-metadata-for-offline-signers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../proposed/0048-session-keys-runtime-api.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
